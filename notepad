LESSON 01: REACT JS roadmap | chai aur react series

Why to learn React ? 
    - hype, job, trend, build UI
    - makes easy to manage & build complex frontend

When should I learn React ?
    - After mastering JS
    - most project dont need react in initial phase

Why react was created ?
    - Fanatam (ghost) message problem    
    - facebook (chat ui)
    - No consistency in UI
    - khan academy => unsplash

Dont learn React if:
    - you dont know how JS works or DOM works

React learning Process
    1. go in-depth (Babel, fibre, Virtual DOM, diff algo, hydration)
    2. by making projects (one topic at a time)
    projects like Todo, Calculator, Github API

React is a Library
    - frameworks (military) VS library (cool dude)

Topic to learn:
    - core of React (state or UI manipulation, JSX)
    - component Reusability
    - Reusing of component (Props)
    - How to propagate change (hooks)

Additional Addon to React   
    - Router (React dont have router)
    - state management (React had not state management)
        - Redux, Redux toolkit, zustand, context API
    - class based component
        - legacy code
    BAAS (Backend as a service) Apps
        -social media clone, e-commerce apps
    

EXTRA LESSON 01: Stack and Heap Memory in Javascript
Stack (Primitive), Heap (Non-primitive)
    - stack main eik ke ooper eik data aata hai jb variable declare krte hain to    uska naam aajaata hai stack main. agr stack se koi bhi chz lenge to copy hi milegi aapko original value change nhi hogi lekin agr heap se aapne kch lia to wo reference deta hai, original value change hojayegi saath main.


EXTRA LESSON 02: Javascript Execution Context + Call Stack
jb ham code file dete hain to sbse pehle jo chz banti hai wo hai 'Global Execution Context' jisko refer krdia jaata hai eik variable = 'this' 
is 'this' variable main Global EC rkhdia jaata hai
Javascript eik single threaded hai hr chz processes main hoti hai
- Global Execution Context
- Function Execution Context
- Eval Execution Context (property of global)

code execution ke 2 phase hote hain:
1. Memory Creation Phase
2. Execution Phase 

Step 1: Global Execution - this

Step 2: Memory Phase 
val1 -> undefined
val2 -> undefined
addNum -> definition
result1 -> undefined
result2 -> undefined

Step 3: Execution phase
val1 -> 10
val2 -> 5
result1 = addNum() -> Executional Context (eik naya sandbox bnta hai hr baar function execute hone pr jiske again 2 phase bnte hain aur executional phase ke baad ye sanbox phr delete bhi hojaata hai)
result1 = 15
result2 =  addNum() -> Executional Context (again new box banega)

Executional Context | 01:
new variable environment + execution thread
    - Memory phase: 
        val1 -> undefined
        val2 -> undefined
        total -> undefined

    - Execution context (actual processing)
        num1 -> 10
        num2 -> 5
        total -> 15 (returned to global executional context )
variable return hojayega hai global executional context main

Executional Context | 02:
NVE + thread
    - Memory phase: 
        val1 -> undefined
        val2 -> undefined
        total -> undefined

    - Execution context (actual processing)
        num1 -> 10
        num2 -> 2
        total -> 12 (returned to global executional context )
variable return hojayega hai global executional context main

Call Stack: (lifo method)
    is main bhi sbse pehle global execution to hota hi hai aur phr jese jese function bnta hai call stack ke andr aata hai execute hota hai nikal jaata hai lekin do ya teen call hogaye to jo last main aaya wo pehle execute hoga just like lifo method




Summary:
The working of the JavaScript works on three phases:
1. Global Execution Context
2. Memory phase / Creation phase
3. Execution phase

Phase 1: Global Execution Context
The value of `this` keyword is set to Global Execution Context (which is an empty Object in NODE environment, & window object in browser environment)

Phase 2: Memory phase
During this phase, JS engine scans the code and assigns the initial values for the variables , functions, etc.. For variables they are 'undefined' and for functions they are set to their function definition

Phase 3: Execution phase
After the creation phase completed, the execution phase begins where actual values of the variables are set. And when the functions are called it creates a new 'Function Execution' context which consists of two phases (they works same as explained above but only for the particular function scope):
1. Memory phase 
2. Execution phase 
The return value of the 'Function Execution' context is passed to the Global Execution Context